<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Nginx 反向代理</title>
    <url>/2024/07/14/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="Nginx-反向代理-Tomcat-为例"><a href="#Nginx-反向代理-Tomcat-为例" class="headerlink" title="Nginx 反向代理(Tomcat 为例)"></a>Nginx 反向代理(Tomcat 为例)</h2><p><img src="/../picture/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/1.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ano # 查看端口信息</span><br></pre></td></tr></table></figure>



<h3 id="配置-tomcat-相关信息："><a href="#配置-tomcat-相关信息：" class="headerlink" title="配置 tomcat 相关信息："></a>配置 tomcat 相关信息：</h3><ul>
<li><strong>打开 apache-tomcat-8.5.93\conf\server.xml 修改信息如下（此处的端口在上面扫描出的端口中并没有被占用的）:</strong></li>
</ul>
<p><img src="/../picture/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/2.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>启动 tonmcat</li>
</ul>
<p><img src="/../picture/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/fee438428101f0aaa1d96deed2be7a07.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>结果图：</p>
<p><img src="/../picture/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/image-20240511221052426.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><ul>
<li>解压压缩包 <a href="https://nginx.org/download/nginx-1.25.5.zip">点击下载文件</a></li>
</ul>
<p><img src="/../picture/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/image-20240511221224754.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx # 命令框启动服务 注意不要开启多个服务</span><br></pre></td></tr></table></figure>

<p><img src="/../picture/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/image-20240511221346532.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><p>修改 <strong>nginx-1.25.5\conf\nginx.conf</strong> 配置文件</p>
<p><img src="/../picture/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/fa4537519a39b94695a45c14accddde7.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /demo &#123;</span><br><span class="line">	proxy_pass http://localhost:8081;</span><br><span class="line">	rewrite ^/demo(.*)$ $1 break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># ^/demo(.*)$ 是一个正则表达式，它匹配以 /demo 开头的 URL，并捕获后续的任意字符（(.*)）。</span><br><span class="line"># $1 表示捕获的内容，它将被替换成重写后的 URL 的一部分。</span><br><span class="line"># break 指令告诉 Nginx 在执行完当前规则后停止匹配其他规则。</span><br><span class="line"></span><br><span class="line"># 如果不加这一行，访问的就是http://localhost/demo/index.html (这里需要注意)</span><br></pre></td></tr></table></figure>



<ul>
<li><p>重新加载nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/../picture/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/image-20240511222009951.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><p>访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost/demo/</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/../picture/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/image-20240511221953362.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="Linux-配置（续）"><a href="#Linux-配置（续）" class="headerlink" title="Linux 配置（续）"></a>Linux 配置（续）</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>生成器使用</title>
    <url>/2024/07/14/%E7%94%9F%E6%88%90%E5%99%A8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="正确配置启动项目-显示验证码即为正常"><a href="#正确配置启动项目-显示验证码即为正常" class="headerlink" title="正确配置启动项目(显示验证码即为正常)"></a>正确配置启动项目(显示验证码即为正常)</h3><p><img src="/../picture/%E7%94%9F%E6%88%90%E5%99%A8%E4%BD%BF%E7%94%A8/image-20240613105922984.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="创建数据表并插入数据"><a href="#创建数据表并插入数据" class="headerlink" title="创建数据表并插入数据"></a>创建数据表并插入数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE renren_security;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_goods (</span><br><span class="line">  id <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品ID&#x27;</span>,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">50</span>) COMMENT <span class="string">&#x27;商品名&#x27;</span>,</span><br><span class="line">  intro <span class="type">varchar</span>(<span class="number">500</span>) COMMENT <span class="string">&#x27;介绍&#x27;</span>,</span><br><span class="line">  price <span class="type">int</span> COMMENT <span class="string">&#x27;价格&#x27;</span>,</span><br><span class="line">  num <span class="type">int</span> COMMENT <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">  creator <span class="type">bigint</span> COMMENT <span class="string">&#x27;创建者&#x27;</span>,</span><br><span class="line">  create_date datetime COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;商品管理&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="运行-renren-generator-下的-GeneratorApplication，浏览器访问"><a href="#运行-renren-generator-下的-GeneratorApplication，浏览器访问" class="headerlink" title="运行  renren-generator 下的 GeneratorApplication，浏览器访问"></a>运行  renren-generator 下的 GeneratorApplication，浏览器访问</h3><p><a href="http://localhost:8082/renren-generator/#generator.html">http://localhost:8082/renren-generator/#generator.html</a></p>
<p><img src="/../picture/%E7%94%9F%E6%88%90%E5%99%A8%E4%BD%BF%E7%94%A8/image-20240613110145816.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="下载完代码后："><a href="#下载完代码后：" class="headerlink" title="下载完代码后："></a>下载完代码后：</h3><p><img src="/../picture/%E7%94%9F%E6%88%90%E5%99%A8%E4%BD%BF%E7%94%A8/image-20240613110324170.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="复制下载代码中的-main-文件夹："><a href="#复制下载代码中的-main-文件夹：" class="headerlink" title="复制下载代码中的 main 文件夹："></a>复制下载代码中的 main 文件夹：</h3><p><img src="/../picture/%E7%94%9F%E6%88%90%E5%99%A8%E4%BD%BF%E7%94%A8/image-20240613110500553.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="运行-AdminApplication"><a href="#运行-AdminApplication" class="headerlink" title="运行 AdminApplication"></a>运行 AdminApplication</h3><h3 id="复制-vue-文件夹中的-demo-文件夹到-RENREN-UI文件夹下的-views"><a href="#复制-vue-文件夹中的-demo-文件夹到-RENREN-UI文件夹下的-views" class="headerlink" title="复制  vue 文件夹中的 demo 文件夹到 RENREN-UI文件夹下的 views"></a>复制  vue 文件夹中的 demo 文件夹到 RENREN-UI文件夹下的 views</h3><p><img src="/../picture/%E7%94%9F%E6%88%90%E5%99%A8%E4%BD%BF%E7%94%A8/image-20240613110643392.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="修改路由文件"><a href="#修改路由文件" class="headerlink" title="修改路由文件"></a>修改路由文件</h3><p><img src="/../picture/%E7%94%9F%E6%88%90%E5%99%A8%E4%BD%BF%E7%94%A8/image-20240613110711758.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Layout</span> <span class="keyword">from</span> <span class="string">&quot;@/layout/layout.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Error</span> <span class="keyword">from</span> <span class="string">&quot;@/views/error.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouteRecordRaw</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&quot;@/views/login.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Iframe</span> <span class="keyword">from</span> <span class="string">&quot;@/views/iframe.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Goods</span> <span class="keyword">from</span> <span class="string">&quot;@/views/demo/goods.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">GoodsAdd</span> <span class="keyword">from</span> <span class="string">&quot;@/views/demo/goods-add-or-update.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 框架基础路由</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;工作台&quot;</span>, <span class="attr">icon</span>: <span class="string">&quot;icon-desktop&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/home.vue&quot;</span>),</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;主页&quot;</span>, <span class="attr">icon</span>: <span class="string">&quot;icon-home&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/goods&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">Goods</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;商品管理&quot;</span>, <span class="attr">icon</span>: <span class="string">&quot;icon-goods&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/goods/add&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">GoodsAdd</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;添加或更新商品&quot;</span>, <span class="attr">icon</span>: <span class="string">&quot;icon-goods-add&quot;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Login</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;登录&quot;</span>, <span class="attr">isNavigationMenu</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/user/password&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/sys/user-update-password.vue&quot;</span>),</span><br><span class="line">    <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;修改密码&quot;</span>, <span class="attr">requiresAuth</span>: <span class="literal">true</span>, <span class="attr">isNavigationMenu</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/iframe/:id?&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Iframe</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;iframe&quot;</span>, <span class="attr">isNavigationMenu</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/error&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Error</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&quot;错误页面&quot;</span>, <span class="attr">isNavigationMenu</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">errorRoute</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/:path(.*)*&quot;</span>,</span><br><span class="line">    <span class="attr">redirect</span>: &#123; <span class="attr">path</span>: <span class="string">&quot;/error&quot;</span>, <span class="attr">query</span>: &#123; <span class="attr">to</span>: <span class="number">404</span> &#125;, <span class="attr">replace</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="attr">meta</span>: &#123; <span class="attr">isNavigationMenu</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> routes;</span><br></pre></td></tr></table></figure>

<h3 id="浏览器登录-点击商品管理"><a href="#浏览器登录-点击商品管理" class="headerlink" title="浏览器登录  点击商品管理"></a>浏览器登录  点击商品管理</h3><p><img src="/../picture/%E7%94%9F%E6%88%90%E5%99%A8%E4%BD%BF%E7%94%A8/image-20240613110831529.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>序列化-protobuf</title>
    <url>/2024/07/14/%E5%BA%8F%E5%88%97%E5%8C%96-protobuf/</url>
    <content><![CDATA[<h1 id="1-序列化"><a href="#1-序列化" class="headerlink" title="1. 序列化"></a>1. 序列化</h1><blockquote>
<p>序列化 (Serialization)将对象的<strong>状态信息转换为</strong>可以<strong>存储或传输的形式的过程</strong>，与之相对应的过程称之为反序列化（Unserialization）。<strong>序列化和反序列化主要用于解决在跨平台和跨语言的情况下, 模块之间的交互和调用，但其本质是为了解决数据传输问题</strong>。 </p>
<p>实现数据序列化:</p>
<ul>
<li>要有原始数据<ul>
<li>复合类型 -&gt; 最常见的情况</li>
<li>基础数据类型</li>
</ul>
</li>
<li>通过某些方式 -&gt; 另外一种形式的数据</li>
<li>得到的数据干啥? -&gt; 目的: 进行分发, 分发到不同的终端&#x2F;平台, 保证不同的平台能正确解析<ul>
<li>网络传输</li>
<li>磁盘拷贝</li>
</ul>
</li>
</ul>
<p><font color="red">序列化目的不是为了加密, 为的是数据的跨平台传输</font></p>
<p>序列化的整体过程:</p>
<ul>
<li>发送端<ul>
<li>原始数据 -&gt; 序列化 (编码) -&gt; 特殊格式的字符串</li>
<li>发送这个字符串</li>
</ul>
</li>
<li>接收端:<ul>
<li>接收数据</li>
<li>特殊格式的字符串 -&gt; 反序列化 (解码) -&gt; 原始数据</li>
<li>对原始数据进行处理</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="1-1-网络通信中的问题分析"><a href="#1-1-网络通信中的问题分析" class="headerlink" title="1.1 网络通信中的问题分析"></a>1.1 网络通信中的问题分析</h2><p>发送过程中遇到的一些问题?</p>
<ul>
<li><p>平台不同</p>
<ul>
<li>32bit &#x2F; 64bit <ul>
<li>long</li>
</ul>
</li>
<li>平台不同, 某些数据类型占用的内存大小不同</li>
</ul>
</li>
<li><p>如果不是字符串, 需要进行字节序转换</p>
<ul>
<li><p>字符串没有字节序问题, 字符在内存中只占一个字节</p>
</li>
<li><p>如果发送的是结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">12</span>];</span><br><span class="line">    <span class="type">long</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test t;</span><br><span class="line">send()/write()</span><br><span class="line">send(fd, (<span class="type">void</span>*)t, <span class="keyword">sizeof</span>(t), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>大小端问题</p>
</li>
</ul>
</li>
<li><p>语言不同</p>
<ul>
<li>语言不同数据类型占用的内存有可能不同<ul>
<li>c -&gt; char -&gt; 1字节</li>
<li>java -&gt; char -&gt; 2字节</li>
</ul>
</li>
</ul>
</li>
<li><p>字节对齐问题</p>
</li>
</ul>
<h2 id="1-2-常用的序列化方式"><a href="#1-2-常用的序列化方式" class="headerlink" title="1.2 常用的序列化方式"></a>1.2 常用的序列化方式</h2><ol>
<li><p>XML（ Extensible Markup Language ）类似于html</p>
<blockquote>
<p>XML是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点。XML历史悠久，其1.0版本早在1998年就形成标准，并被广泛使用至今。</p>
<p>XML的最初产生目标是对互联网文档进行标记，所以它的设计理念中就包含了对于人和机器都具备可读性。 但是，当这种标记文档的设计被用来序列化对象的时候，就显得冗长而复杂。</p>
<p>XML基本格式:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Library</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Type</span> <span class="attr">name</span>=<span class="string">&quot;小说&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Book</span> <span class="attr">author</span>=<span class="string">&quot;J.K.ROWLING&quot;</span> <span class="attr">price</span>=<span class="string">&quot;12$&quot;</span>&gt;</span>哈利波特1<span class="tag">&lt;/<span class="name">Book</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Book</span> <span class="attr">author</span>=<span class="string">&quot;J.K.ROWLING&quot;</span> <span class="attr">price</span>=<span class="string">&quot;12$&quot;</span>&gt;</span>哈利波特2<span class="tag">&lt;/<span class="name">Book</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Book</span> <span class="attr">author</span>=<span class="string">&quot;J.K.ROWLING&quot;</span> <span class="attr">price</span>=<span class="string">&quot;12$&quot;</span>&gt;</span>哈利波特3<span class="tag">&lt;/<span class="name">Book</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Book</span> <span class="attr">author</span>=<span class="string">&quot;J.K.ROWLING&quot;</span> <span class="attr">price</span>=<span class="string">&quot;12$&quot;</span>&gt;</span>哈利波特4<span class="tag">&lt;/<span class="name">Book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Type</span> <span class="attr">name</span>=<span class="string">&quot;历史&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Book</span> <span class="attr">author</span>=<span class="string">&quot;司马迁&quot;</span> <span class="attr">price</span>=<span class="string">&quot;20$&quot;</span>&gt;</span>史记<span class="tag">&lt;/<span class="name">Book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Library</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Json（ JavaScript Object Notation ）</p>
<blockquote>
<p>JSON起源于弱类型语言Javascript，它的产生来自于一种称之为”关联数组（Associative array）”的概念，其本质是就是采用”键值对”的方式来描述对象。</p>
<p>JSON格式保持了XML的人眼可读的优点，非常符合工程师对对象的理解。</p>
<p>相对于XML而言，序列化后的数据更加简洁（XML所产生序列化之后文件的大小接近JSON的两倍），而且其协议比较简单，解析速度比较快。</p>
<p>JSON格式具备Javascript的先天性支持，所以被广泛应用于Web browser的应用常景中，是Ajax的事实标准协议。</p>
<p>更多资料可查看：<a href="http://json.org/">http://json.org/</a></p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// json是一种数据格式, 不是语言, 和平台语言无关</span></span><br><span class="line"><span class="comment">// json数组</span></span><br><span class="line"><span class="punctuation">[</span>整形<span class="punctuation">,</span> 浮点型<span class="punctuation">,</span> 布尔类型<span class="punctuation">,</span> 字符串<span class="punctuation">,</span> json数组<span class="punctuation">,</span> json对象<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">12</span><span class="punctuation">,</span> <span class="number">12.44</span><span class="punctuation">,</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="string">&quot;hello&quot;</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">// json对象</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span><span class="string">&quot;value&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">json对象中是n个键值对</span><br><span class="line">key<span class="punctuation">:</span> 必须是字符串</span><br><span class="line">value<span class="punctuation">:</span> </span><br><span class="line">	整形</span><br><span class="line">	浮点型</span><br><span class="line">	布尔</span><br><span class="line">	字符串</span><br><span class="line">	json数组</span><br><span class="line">	json对象</span><br><span class="line"></span><br><span class="line">注意事项<span class="punctuation">:</span></span><br><span class="line">	在一个文件中只能存储一个大的数组或者对象<span class="punctuation">,</span> 但是可以嵌套使用</span><br><span class="line">	原素和原始之间使用逗号间隔(一个键值对视为一个元素)</span><br><span class="line">	最后一个元素后边没有逗号</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;lilei&quot;</span><span class="punctuation">:</span><span class="string">&quot;112334&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tom&quot;</span><span class="punctuation">:</span><span class="string">&quot;helolll&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lucy&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxxxyyyy&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span> <span class="string">&quot;历史&quot;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;张三&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;father&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三丰&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;mother&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sister&quot;</span><span class="string">&quot;xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;favorite&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;足球&quot;</span><span class="punctuation">,</span> <span class="string">&quot;乒乓&quot;</span><span class="punctuation">,</span> <span class="string">&quot;游泳&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">	<span class="attr">&quot;李四&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Protocol Buffer</p>
</li>
<li><p>ASN.1 抽象语法标记(Abstract Syntax Notation One) </p>
</li>
<li><p>boost 序列化的类</p>
</li>
</ol>
<h1 id="2-protobuf"><a href="#2-protobuf" class="headerlink" title="2. protobuf"></a>2. protobuf</h1><blockquote>
<p>Protocol Buffer( 简称 Protobuf) 是Google公司内部的混合语言数据标准，它是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，很适合做数据存储或RPC 数据交换格式。</p>
<p>Protobuf是一个纯粹的展示层协议，可以和各种传输层协议一起使用，Protobuf的文档也非常完善。google 提供了多种语言的实现：java、c#、c++、go 和 python，每一种实现都包含了相应语言的编译器以及库文件。</p>
<p>Protobuf支持的数据类型相对较少，不支持常量类型。由于其设计的理念是纯粹的展现层协议，目前并没有一个专门支持Protobuf的RPC框架。</p>
<p>更多资料可查看：<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
</blockquote>
<h2 id="2-1-操作流程"><a href="#2-1-操作流程" class="headerlink" title="2.1 操作流程"></a>2.1 操作流程</h2><blockquote>
<ul>
<li>准备数据<ul>
<li>复合类型: 结构体&#x2F; 类</li>
<li>基础类型</li>
</ul>
</li>
<li>创建一个新文件 <code>xxx.proto</code></li>
<li>将我们要序列化的数据 -&gt; 写入到proto文件<ul>
<li>有语法格式</li>
</ul>
</li>
<li>通过一个命令 <code>protoc</code>将<code>xxx.proto</code>文件生成一个c++的类 <ul>
<li>对应一个头文件&#x2F; 源文件</li>
<li>操作命令-&gt; 在window终端中: <code>protoc xxx.proto --cpp_out=./</code></li>
</ul>
</li>
<li>直接使用这个类<ul>
<li>里边有对数据操作的api<ul>
<li>读数据 api<ul>
<li>方法名字 <code>变量名()</code></li>
</ul>
</li>
<li>写数据 api<ul>
<li>方法名字: <code>set_变量名(arg)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要序列化的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">string</span> sex;	<span class="comment">// man woman</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在.proto文件中定义消息格式</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// protobuf的版本</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;	<span class="comment">// proto2</span></span><br><span class="line"><span class="comment">// 组织Persion结构体</span></span><br><span class="line"><span class="comment">// 语法格式</span></span><br><span class="line">message 关键字(相当于被创建出的类的名字)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 成员变量</span></span><br><span class="line">	数据类型 变量名 = 变量的编号;	<span class="comment">// 编号从1开始, 不能重复</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .proto文件 生成 c++ 类的命令</span></span><br><span class="line">protoc proto文件名 --cpp_out=生成目录</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">.proto类型</th>
<th align="center">**C++**类型</th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">double</td>
<td align="center">double</td>
<td>64位浮点数</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">float</td>
<td>32位浮点数</td>
</tr>
<tr>
<td align="center">int32</td>
<td align="center">int32</td>
<td>32位整数</td>
</tr>
<tr>
<td align="center">int64</td>
<td align="center">int64</td>
<td>64位整数</td>
</tr>
<tr>
<td align="center">uint32</td>
<td align="center">uint32</td>
<td>32位无符号整数</td>
</tr>
<tr>
<td align="center">uint64</td>
<td align="center">uint64</td>
<td>64位无符号整数</td>
</tr>
<tr>
<td align="center">sint32</td>
<td align="center">sint32</td>
<td>32位整数，处理负数效率比int32更高</td>
</tr>
<tr>
<td align="center">sint64</td>
<td align="center">sint64</td>
<td>64位整数，处理负数效率比int64更高</td>
</tr>
<tr>
<td align="center">fixed32</td>
<td align="center">uint32</td>
<td>总是4个字节。如果数值总是比总是比228大的话，这个类型会比uint32高效。</td>
</tr>
<tr>
<td align="center">fixed64</td>
<td align="center">uint64</td>
<td>总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。</td>
</tr>
<tr>
<td align="center">sfixed32</td>
<td align="center">int32</td>
<td>总是4个字节</td>
</tr>
<tr>
<td align="center">sfixed64</td>
<td align="center">int64</td>
<td>总是8个字节</td>
</tr>
<tr>
<td align="center">bool</td>
<td align="center">bool</td>
<td>布尔类型</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">string</td>
<td>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本</td>
</tr>
<tr>
<td align="center">bytes</td>
<td align="center">string</td>
<td>处理多字节的语言字符、如中文</td>
</tr>
<tr>
<td align="center">enum</td>
<td align="center">enum</td>
<td>枚举</td>
</tr>
<tr>
<td align="center">message</td>
<td align="center">object of class</td>
<td>自定义的消息类型</td>
</tr>
</tbody></table>
</li>
<li><p>repeated限定修饰符</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Persion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;   <span class="comment">// 编号从1开始</span></span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> sex = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int32</span> age = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要求name有多个 -&gt; 数组</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Persion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;   <span class="comment">// 编号从1开始</span></span><br><span class="line">    <span class="comment">// vector&lt;string&gt; name;</span></span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">bytes</span> name = <span class="number">2</span>;	<span class="comment">// name可以在程序中创建多个, 在程序中作为动态数组来使用</span></span><br><span class="line">    <span class="type">string</span> sex = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int32</span> age = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// 定义枚举</span></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">	Red = <span class="number">0</span>;	<span class="comment">// protbuf中第一个枚举值必须为0</span></span><br><span class="line">	Green = <span class="number">6</span>;</span><br><span class="line">	Blue = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Persion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;   <span class="comment">// 编号从1开始</span></span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> sex = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int32</span> age = <span class="number">4</span>;</span><br><span class="line">    Color color = <span class="number">5</span>;	<span class="comment">// 枚举变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>proto文件的导入</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Persion.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// 导入另外一个proto文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;Info.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">	Red = <span class="number">0</span>;	<span class="comment">// protbuf中第一个枚举值必须为0</span></span><br><span class="line">	Green = <span class="number">6</span>;</span><br><span class="line">	Blue = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Persion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;   <span class="comment">// 编号从1开始</span></span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">bytes</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> sex = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int32</span> age = <span class="number">4</span>;</span><br><span class="line">    Color color = <span class="number">5</span>;</span><br><span class="line">    Info info = <span class="number">6</span>;	<span class="comment">// Info对象, 导入的proto文件中的类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Info.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Info</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bytes</span> address = <span class="number">1</span>;  <span class="comment">// 地址</span></span><br><span class="line">    <span class="type">int32</span> number = <span class="number">2</span>;   <span class="comment">// 门牌号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>包 -&gt; 命名空间</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Persion.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// 导入另外一个proto文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;Info.proto&quot;</span>;</span><br><span class="line"><span class="comment">// 添加命名空间</span></span><br><span class="line"><span class="keyword">package</span> itcast;	<span class="comment">// Persion类属于itcast这个命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">	Red = <span class="number">0</span>;	<span class="comment">// protbuf中第一个枚举值必须为0</span></span><br><span class="line">	Green = <span class="number">6</span>;</span><br><span class="line">	Blue = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Persion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;   <span class="comment">// 编号从1开始</span></span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">bytes</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> sex = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int32</span> age = <span class="number">4</span>;</span><br><span class="line">    Color color = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 命名空间.类名</span></span><br><span class="line">    itheima.Info info = <span class="number">6</span>;	<span class="comment">// Info对象, 导入的proto文件中的类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Info.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// Persion类属于itheima这个命名空间</span></span><br><span class="line"><span class="keyword">package</span> itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Persion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bytes</span> address = <span class="number">1</span>;  <span class="comment">// 地址</span></span><br><span class="line">    <span class="type">int32</span> number = <span class="number">2</span>;   <span class="comment">// 门牌号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>使用protobuf编译器生成C++类</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">protobuf编译器, 编译源码得到的 protoc.exe</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--cpp_out 生成的c++类的位置</span></span><br><span class="line">protoc.exe xxx.proto --cpp_out=目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用C++ API来读写消息</p>
<ul>
<li>读: <code>变量名()</code></li>
<li>写: <code>set_变量名(arg1, arg2, ...)</code></li>
</ul>
</li>
<li><p>vs配置 -&gt; 添加宏</p>
<p><img src="/../picture/%E5%BA%8F%E5%88%97%E5%8C%96-protobuf/1566718547217.png" alt="1566718547217"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
</ul>
<h1 id="3-业务数据分析"><a href="#3-业务数据分析" class="headerlink" title="3. 业务数据分析"></a>3. 业务数据分析</h1><h2 id="3-1-客户端"><a href="#3-1-客户端" class="headerlink" title="3.1 客户端"></a>3.1 客户端</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 准备要发送的数据</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RequestMsg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1 密钥协商 //2 密钥校验; // 3 密钥注销</span></span><br><span class="line">    <span class="type">int</span> cmdType; <span class="comment">// 报文类型</span></span><br><span class="line">    string clientId; <span class="comment">// 客户端编号</span></span><br><span class="line">    string serverId; <span class="comment">// 服务器端编号</span></span><br><span class="line">    string sign;</span><br><span class="line">    string data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">RequestMsg</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32</span> cmdType;</span><br><span class="line">	<span class="type">bytes</span> clientId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-2-服务器端"><a href="#3-2-服务器端" class="headerlink" title="3.2 服务器端"></a>3.2 服务器端</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RespondMsg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">bool</span> rv; <span class="comment">// 返回值</span></span><br><span class="line">    <span class="type">int</span> seckeyid; 		<span class="comment">// 对称密钥编号 keysn</span></span><br><span class="line">    <span class="built_in">string</span> clientId; 	<span class="comment">// 客户端编号</span></span><br><span class="line">    <span class="built_in">string</span> serverId; 	<span class="comment">// 服务器编号</span></span><br><span class="line">    <span class="built_in">string</span> data; 	<span class="comment">// 服务器端随机数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/../picture/%E5%BA%8F%E5%88%97%E5%8C%96-protobuf/protobuf.svg"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>git的基本操作</title>
    <url>/2024/07/15/git/</url>
    <content><![CDATA[<p><img src="/../picture/git/timg.jpg" alt="img"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="1-git介绍"><a href="#1-git介绍" class="headerlink" title="1. git介绍"></a>1. git介绍</h1><h2 id="1-1-版本控制系统"><a href="#1-1-版本控制系统" class="headerlink" title="1.1. 版本控制系统"></a>1.1. 版本控制系统</h2><ul>
<li><p>集中式版本控制系统</p>
<blockquote>
<p>集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。</p>
<p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，那就GG了.  </p>
</blockquote>
<p><img src="/../picture/git/0.jpg"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
<li><p>分布式版本控制系统</p>
<blockquote>
<p>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。</p>
<p>既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？</p>
<p>分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
</blockquote>
<p><img src="/../picture/git/0-1559747872796.jpg" alt="distributed-repo"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
</ul>
<h1 id="2-创建本地版本库"><a href="#2-创建本地版本库" class="headerlink" title="2. 创建本地版本库"></a>2. 创建本地版本库</h1><blockquote>
<p>版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
</blockquote>
<h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><ul>
<li><p>工作区</p>
<ul>
<li>用户自己创建的目录 -&gt; 存放源代码</li>
<li>本地的版本库也需要放到工作区中</li>
<li>每个工作区中都可以创建一个版本库</li>
<li>只有工作区的<code>新文件</code>才需要添加到暂存区</li>
</ul>
</li>
<li><p>版本库</p>
<ul>
<li>就是一个目录: 名字-&gt; .git</li>
<li>管理用于提交的代码</li>
</ul>
</li>
<li><p>暂存区</p>
<ul>
<li>首先创建新文件 -&gt; 在工作区 (和版本库没有关系)</li>
<li>将新文件添加到本地仓库中 -&gt; 新文件被保存在了暂存区 (还是没有进行版本管理)</li>
<li>将暂存区数据提交到版本库 -&gt; 这时候就可以进行版本管理了</li>
<li>暂存区也是一个目录: stage&#x2F;index</li>
</ul>
<p><img src="/../picture/git/0-1559749463798.jpg"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>提交代码的流程<ul>
<li>要在工作区中创建新文件</li>
<li>将工作区中的新文件添加到暂存区<ul>
<li>文件只需要往暂存区添加一次</li>
</ul>
</li>
<li>将暂存区数据提交到版本仓库<ul>
<li>版本仓库中有很多节点, 依次记录着我们提交的各个版本</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-操作步骤"><a href="#2-2-操作步骤" class="headerlink" title="2.2 操作步骤"></a>2.2 操作步骤</h2><ul>
<li><p>创建版本库</p>
<ul>
<li><p>在工作区中鼠标右键</p>
<p><img src="/../picture/git/1566526442145.png" alt="1566526442145"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566526474770.png" alt="1566526474770"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566526548563.png" alt="1566526548563"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
</ul>
</li>
<li><p>添加新文件</p>
<ul>
<li><p>在工作区右键菜单</p>
<p><img src="/../picture/git/1566528567183.png" alt="1566528567183"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566528599191.png" alt="1566528599191"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
</ul>
<p><img src="/../picture/git/0-1559749617853.jpg" alt="git-stage"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
<li><p>提交文件</p>
<ul>
<li><p>鼠标右键</p>
<p><img src="/../picture/git/1566528777385.png" alt="1566528777385"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566528858759.png" alt="1566528858759"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
</ul>
<p><img src="/../picture/git/0-1559749634079.jpg" alt="git-stage-after-commit"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
</ul>
<h1 id="3-修改文件"><a href="#3-修改文件" class="headerlink" title="3. 修改文件"></a>3. 修改文件</h1><ul>
<li><p>修改工作区文件</p>
<ul>
<li>修改完文件之后直接提交, 不需要再次添加到暂存区</li>
</ul>
</li>
<li><p>修改完之后 的数据需要提交到本地的版本仓库中</p>
</li>
<li><p>还原修改</p>
<ul>
<li>还原之后数据就不能再恢复了</li>
</ul>
<p><img src="/../picture/git/1566529272163.png" alt="1566529272163"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
<li><p>查看修改历史</p>
<ul>
<li>比较当前查看的版本和上一个版本的区别</li>
<li>可以导出某一个需要的版本, 在当前版本上鼠标右键:<ul>
<li><img src="/../picture/git/1566530146255.png" alt="1566530146255"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><img src="/../picture/git/1566529629315.png" alt="1566529629315"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
</li>
<li><p>差异比较</p>
<p><img src="/../picture/git/1566530323067.png" alt="1566530323067"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
<li><p>删除文件</p>
<ul>
<li>可以手动删除 -&gt; delete 键</li>
</ul>
</li>
<li><p>通过菜单项删除</p>
</li>
</ul>
<p><img src="/../picture/git/1566530793162.png" alt="1566530793162"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>注意事项:<code>删除操作之后必须要提交</code></li>
</ul>
<h1 id="4-练习-添加一个本地项目到仓库"><a href="#4-练习-添加一个本地项目到仓库" class="headerlink" title="4. 练习: 添加一个本地项目到仓库"></a>4. 练习: 添加一个本地项目到仓库</h1><ul>
<li><p>设置文件忽略</p>
<p>先选中要忽略的文件, 在这些文件上鼠标右键</p>
<p><img src="/../picture/git/1566532396837.png" alt="1566532396837"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>将设置忽略的动作提交到版本库</p>
</li>
</ul>
<h1 id="5-添加远程仓库"><a href="#5-添加远程仓库" class="headerlink" title="5. 添加远程仓库"></a>5. 添加远程仓库</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">远程仓库作用:</span><br><span class="line">	- 备份本地仓库的代码</span><br><span class="line">	- 多人协同开发, 使用远程仓库合并代码</span><br><span class="line">远程仓库来源:</span><br><span class="line">	- 公司自己搭建</span><br><span class="line">	- 使用现有的远程仓库</span><br><span class="line">		- github</span><br><span class="line">		- 码云</span><br></pre></td></tr></table></figure>



<h2 id="5-1-添加远程仓库"><a href="#5-1-添加远程仓库" class="headerlink" title="5.1 添加远程仓库"></a>5.1 添加远程仓库</h2><p>在线代码托管平台 </p>
<ul>
<li>Github: <a href="https://github.com/">https://github.com/</a></li>
<li>码云: <a href="https://gitee.com/">https://gitee.com/</a></li>
</ul>
<p>创建仓库</p>
<ul>
<li><img src="/../picture/git/1566533262064.png" alt="1566533262064"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li><img src="/../picture/git/1566533665064.png" alt="1566533665064"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
<li><img src="/../picture/git/1566533830369.png" alt="1566533830369"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></li>
</ul>
<h2 id="5-2-本地仓库同步到远程仓库"><a href="#5-2-本地仓库同步到远程仓库" class="headerlink" title="5.2 本地仓库同步到远程仓库"></a>5.2 本地仓库同步到远程仓库</h2><ul>
<li><p>在工作区鼠标右键</p>
<p><img src="/../picture/git/1566533947636.png" alt="1566533947636"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566534031304.png" alt="1566534031304"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
</ul>
<h2 id="5-3-克隆远程仓库到本地"><a href="#5-3-克隆远程仓库到本地" class="headerlink" title="5.3 克隆远程仓库到本地"></a>5.3 克隆远程仓库到本地</h2><ul>
<li><p>进入到远程仓库中, 找到仓库的地址</p>
<p><img src="/../picture/git/1566544062217.png" alt="1566544062217"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
<li><p>将远程地址复制一份</p>
</li>
<li><p>在本地找一个目录, 进行如下操作</p>
<p><img src="/../picture/git/1566544121584.png" alt="1566544121584"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566544205499.png" alt="1566544205499"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
<li><p>第一次需要将远程仓库内容下载到本地的时候, 才需要克隆</p>
</li>
</ul>
<h2 id="5-4-ssh设置"><a href="#5-4-ssh设置" class="headerlink" title="5.4 ssh设置"></a>5.4 ssh设置</h2><ul>
<li><p>在本地生成一个密钥对</p>
<ul>
<li><p>在本地任意目录下, 鼠标右键</p>
<p><img src="/../picture/git/1566544673757.png" alt="1566544673757"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa</span></span><br></pre></td></tr></table></figure>

<p><img src="/../picture/git/1566545000704.png" alt="1566545000704"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><p>本地设置ssh秘钥 -&gt; 私钥</p>
<p><img src="/../picture/git/1566545268559.png" alt="1566545268559"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566545557150.png" alt="1566545557150"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
</ul>
</li>
<li><p>远程仓库设置公钥</p>
<ul>
<li><p>进入当前用户的设置界面</p>
<p><img src="/../picture/git/1566545689936.png" alt="1566545689936"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566545737164.png" alt="1566545737164"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566545824011.png" alt="1566545824011"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
<li><p>使用ssh地址遇到的问题</p>
<p><img src="/../picture/git/1566546069055.png" alt="1566546069055"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 解决方案: 需要修改tortoisegit 使用的 ssh工具</span><br><span class="line"># 需要在 tortoisegit 设置窗口中进行修改</span><br></pre></td></tr></table></figure>

<ul>
<li><p>默认的路径</p>
<p><img src="/../picture/git/1566546228805.png" alt="1566546228805"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
<li><p>修改后的路径</p>
<p><img src="/../picture/git/1566546372033.png" alt="1566546372033"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="6-分支管理"><a href="#6-分支管理" class="headerlink" title="6. 分支管理"></a>6. 分支管理</h1><blockquote>
<p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p>
<p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p>
<p>在版本仓库中有一个默认的分支:<code> master</code>, 当前仓库中有文件之后, 默认分支就被创建了</p>
<p>​	- 如果不创建分支, 分支默认只有一个 : master</p>
</blockquote>
<p><img src="/../picture/git/0.png" alt="learn-branches"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="6-1-创建分支"><a href="#6-1-创建分支" class="headerlink" title="6.1 创建分支"></a>6.1 创建分支</h2><p><img src="/../picture/git/1566547011380.png" alt="1566547011380"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566547074035.png" alt="1566547074035"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="6-2-切换分支"><a href="#6-2-切换分支" class="headerlink" title="6.2 切换分支"></a>6.2 切换分支</h2><p><img src="/../picture/git/1566547131012.png" alt="1566547131012"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566547316804.png" alt="1566547316804"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="6-3-合并分支"><a href="#6-3-合并分支" class="headerlink" title="6.3 合并分支"></a>6.3 合并分支</h2><blockquote>
<p>两个分支进行合并(master, new分支), 最终要合并到那个分支(master), 就先切换到那个分支(master), 切换完成之后, 在选择把哪个分支(new分支)合并到当前分支(master)</p>
</blockquote>
<p><img src="/../picture/git/1566548777614.png" alt="1566548777614"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566548823482.png" alt="1566548823482"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="6-4-解决冲突"><a href="#6-4-解决冲突" class="headerlink" title="6.4 解决冲突"></a>6.4 解决冲突</h2><p><img src="/../picture/git/1566549020854.png" alt="1566549020854"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566549064722.png" alt="1566549064722"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li><p>冲突文件的格式</p>
<p><img src="/../picture/git/1566549230042.png" alt="1566549230042"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>手动修改文件内容, 修改完成之后, 解决冲突</p>
<p><img src="/../picture/git/1566549336456.png" alt="1566549336456"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566549405908.png" alt="1566549405908"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566549482138.png" alt="1566549482138"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
</li>
</ul>
<h1 id="7-推送文件"><a href="#7-推送文件" class="headerlink" title="7. 推送文件"></a>7. 推送文件</h1><blockquote>
<p>有一个远程的仓库-&gt; github, 这不是一个空的仓库, 需要将本地的版本库提交到远程仓库</p>
</blockquote>
<p>直接推送 -&gt; 失败</p>
<p><img src="/../picture/git/1566549817839.png" alt="1566549817839"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<blockquote>
<p>失败的原因:</p>
<ul>
<li>远程仓库不是空的<ul>
<li>有一个默认分支, <code>master</code></li>
</ul>
</li>
<li>本地仓库, 不是空的<ul>
<li>有一个默认分支, <code>master</code></li>
</ul>
</li>
<li>远程仓库和本地仓库默认分支名字相同, 但是这两个分支没有任何关系<ul>
<li>没有关系的分支进行合并 -&gt; 失败</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>解决方案</p>
<blockquote>
<ol>
<li>将远程仓库拉取到本地(pull)<ul>
<li>拉取: 直接将远程仓库分支中的信息和本地分支进行合并</li>
<li>获取: 将远程仓库分支复制到本地的另外一个分支中, 不会合并<ul>
<li>分支名字: fetch_head</li>
</ul>
</li>
</ul>
</li>
<li>将两个分支进行强行合并</li>
<li>将本地分支数据推送动到远程仓库</li>
</ol>
</blockquote>
</li>
<li><p>通过进行获取操作, 得到新分支<code>FETCH_HEAD</code></p>
</li>
</ul>
<p><img src="/../picture/git/1566550553280.png" alt="1566550553280"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>合并分支: 得到的新分支<code>FETCH_HEAD</code>分支合并到本地<code>master</code>分支</li>
</ul>
<p><img src="/../picture/git/1566550645559.png" alt="1566550645559"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><img src="/../picture/git/1566550709001.png" alt="1566550709001"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<ul>
<li>将本地仓库推动到远程仓库</li>
</ul>
<p><img src="/../picture/git/1566550772679.png" alt="1566550772679"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h1 id="8-使用最多的场景"><a href="#8-使用最多的场景" class="headerlink" title="8. 使用最多的场景"></a>8. 使用最多的场景</h1><blockquote>
<p>远程仓库分支和本地仓库分支有关系的情况, 该如何操作?</p>
<ul>
<li>本地:<ul>
<li>修改代码提交到本地仓库</li>
<li>提交到远程仓库<ul>
<li>不能直接提交</li>
<li>在推送之前应该将远程仓库代码<code>拉取</code>到本地<ul>
<li>进程代码合并<ul>
<li>有可能冲突 -&gt; 手动解决冲突</li>
</ul>
</li>
</ul>
</li>
<li>将新的代码推动到远程仓库</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>套接字的多种可选项</title>
    <url>/2024/07/17/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%8F%AF%E9%80%89%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="1-套接字的多种可选项"><a href="#1-套接字的多种可选项" class="headerlink" title="1. 套接字的多种可选项"></a>1. 套接字的多种可选项</h2><table>
<thead>
<tr>
<th align="center">协议层</th>
<th>选项名</th>
<th>读取</th>
<th>设置</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SOL_SOCKET<br />(IP协议相关事项)</td>
<td>SO_SNDBUF<br />SO_RCVBUF<br />SO_REUSEADDR<br />SO_KEEPALIVE<br />SO_BROADCAST<br />SO_DONTROUTE<br />SO_OOBINLINE<br />SO_ERROR<br />SO_TYPE</td>
<td>O<br />O<br />O<br />O<br />O<br />O<br />O<br />O<br />O</td>
<td>O<br />O<br />O<br />O<br />O<br />O<br />O<br />X<br />X</td>
</tr>
<tr>
<td align="center">IPPROTO_IP<br />（TCP协议相关事项）</td>
<td>IP_TOS<br />TO_TTL<br />IP_MULTICAST_TTL<br />IP_MULTICAST_LOOP<br />IP_MULTICAST_IF</td>
<td>O<br />O<br />O<br />O<br />O</td>
<td>O<br />O<br />O<br />O<br />O</td>
</tr>
<tr>
<td align="center">IPPROTO_TCP<br />（套接字相关的通用可选项）</td>
<td>TCP_KEEPALIVE<br />TCP_NODELAY<br />TCP_MAXSEG</td>
<td>O<br />O<br />O</td>
<td>O<br />O<br />O</td>
</tr>
</tbody></table>
<h2 id="2-getsockopt-setsockopt"><a href="#2-getsockopt-setsockopt" class="headerlink" title="2. getsockopt &amp;&amp; setsockopt"></a>2. getsockopt &amp;&amp; setsockopt</h2><p>​		我们几乎可以这对上表中的所有可选项进行读取(Get)和设置(Set)，当然有些可选项只能进行一种操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">void</span>* optval, <span class="type">socklen_t</span>* optlen)</span></span>;</span><br><span class="line">	-&gt; 成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br><span class="line">        • sock		用于查看选项套接字文件描述符</span><br><span class="line">        • level		要查看的可选项的协议层</span><br><span class="line">        • optname	要查看的可选项名</span><br><span class="line">        • optval	保存查看结果的缓冲地址值</span><br><span class="line">        • optlen	向第四个参数(optval)传递的缓冲区大小。调用函数后，该变量中保存通过第四个参数返回的可选项信息的字节数</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span>* optval, <span class="type">socklen_t</span> optlen)</span></span>;</span><br><span class="line">	-&gt; 成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br><span class="line">        • sock		用于更改可选项的套接字文件描述符</span><br><span class="line">        • level		要更改的可选项的协议层</span><br><span class="line">        • optname	要更改的可选项名</span><br><span class="line">        • optval	保存要更改的选项信息的缓冲地址值</span><br><span class="line">        • optlen	向第四个参数(optval)传递的可选项信息的字节数。</span><br></pre></td></tr></table></figure>

<ul>
<li><p><em><strong>Example: (setsockopt())</strong></em></p>
<blockquote>
<p>sock_type.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handing</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tcp_sock, udp_sock;</span><br><span class="line">    <span class="type">int</span> sock_type;</span><br><span class="line">    <span class="type">socklen_t</span> optlen;</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line">    optlen = <span class="built_in">sizeof</span>(sock_type);</span><br><span class="line">    tcp_sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    udp_sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SOCK_STREAM: %d\n&quot;</span>, SOCK_STREAM);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SOCK_DGRAM: %d\n&quot;</span>, SOCK_DGRAM);</span><br><span class="line"></span><br><span class="line">    state = <span class="built_in">getsockopt</span>(tcp_sock, SOL_SOCKET, SO_TYPE, (<span class="type">void</span>*)&amp;sock_type, &amp;optlen);</span><br><span class="line">    <span class="keyword">if</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handing</span>(<span class="string">&quot;getsockopt error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Socket type one: %d\n&quot;</span>, sock_type);</span><br><span class="line"></span><br><span class="line">    state = <span class="built_in">getsockopt</span>(udp_sock, SOL_SOCKET, SO_TYPE, (<span class="type">void</span>*)&amp;sock_type, &amp;optlen);</span><br><span class="line">    <span class="keyword">if</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handing</span>(<span class="string">&quot;getsockopt error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Socket type two: %d\n&quot;</span>, sock_type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result：</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter09# vi sock_type.cpp</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter09# g++ sock_type.cpp -o sock_type</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter09# ./sock_type </span><br><span class="line">SOCK_STREAM: 1</span><br><span class="line">SOCK_DGRAM: 2</span><br><span class="line">Socket type one: 1</span><br><span class="line">Socket type two: 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是TCP套接字，SOCK_STREAM常数值1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是UDP套接字，SPCK_DGRAM常数值2</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用于验证套接字类型的SO_TYPE是只读可选项(套接字类型只能在创建时决定，以后不再能改变)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-SO-SNDBUF-SO-RCVBUF"><a href="#3-SO-SNDBUF-SO-RCVBUF" class="headerlink" title="3. SO_SNDBUF &amp;&amp; SO_RCVBUF"></a>3. SO_SNDBUF &amp;&amp; SO_RCVBUF</h2><p>​    创建套接字将同时生成 <strong>I&#x2F;O</strong> 缓冲区，接下来介绍 **I&#x2F;O **缓冲区相关可选项。</p>
<ul>
<li><p><strong>SO_RCVBUF</strong> 是输入缓冲区大小相关可选项</p>
</li>
<li><p><strong>SO_SNDBUF</strong> 是输出缓冲区大小相关可选项</p>
<p><em><strong>Example(读取 I&#x2F;O 大小):</strong></em></p>
<blockquote>
<p>get_buf.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">int</span> snd_buf, rcv_buf, state;</span><br><span class="line">    <span class="type">socklen_t</span> len;</span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    len = <span class="built_in">sizeof</span>(snd_buf);</span><br><span class="line"></span><br><span class="line">    state = <span class="built_in">getsockopt</span>(sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span>*)&amp;snd_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;getsockopt error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sizeof</span>(rcv_buf);</span><br><span class="line">    state = <span class="built_in">getsockopt</span>(sock, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span>*)&amp;rcv_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;getsockopt error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input buffer size: %d\n&quot;</span>, rcv_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Output buffer size: %d\n&quot;</span>, snd_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result:</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter09# vi get_buf.cpp</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter09# g++ get_buf.cpp -o get_buf</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter09# ./get_buf </span><br><span class="line">Input buffer size: 131072</span><br><span class="line">Output buffer size: 16384</span><br></pre></td></tr></table></figure>

<p><em><strong>Example(更改 I&#x2F;O 大小):</strong></em></p>
<blockquote>
<p>set_buf.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">int</span> snd_buf = <span class="number">1024</span> * <span class="number">3</span>, rcv_buf = <span class="number">1024</span> * <span class="number">3</span>; <span class="comment">// 设置为 3k</span></span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    <span class="type">socklen_t</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更改缓冲区大小</span></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    state = <span class="built_in">setsockopt</span>(sock, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span> *)&amp;rcv_buf, <span class="built_in">sizeof</span>(rcv_buf));</span><br><span class="line">    <span class="keyword">if</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;setsockopt() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state = <span class="built_in">setsockopt</span>(sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span> *)&amp;snd_buf, <span class="built_in">sizeof</span>(snd_buf));</span><br><span class="line">    <span class="keyword">if</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;setsockopt() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取缓冲区大小</span></span><br><span class="line">    len = <span class="built_in">sizeof</span>(snd_buf);</span><br><span class="line">    state = <span class="built_in">getsockopt</span>(sock, SOL_SOCKET, SO_SNDBUF, (<span class="type">void</span> *)&amp;snd_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;getsockopt() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sizeof</span>(rcv_buf);</span><br><span class="line">    state = <span class="built_in">getsockopt</span>(sock, SOL_SOCKET, SO_RCVBUF, (<span class="type">void</span> *)&amp;rcv_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;getsockopt() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input buffer size: %d \n&quot;</span>, rcv_buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Output buffer size: %d \n&quot;</span>, snd_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><strong>Result:</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter09# g++ set_buf.cpp -o set_buf</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter09# ./set_buf </span><br><span class="line">Input buffer size: 6144 </span><br><span class="line">Output buffer size: 6144</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缓冲区的设置需要谨慎处理，因此不会完全按照我们的要求进行</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-SO-REUSEADDR"><a href="#4-SO-REUSEADDR" class="headerlink" title="4. SO_REUSEADDR"></a>4. SO_REUSEADDR</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, client_sock;</span><br><span class="line">    <span class="type">char</span> message[<span class="number">30</span>];</span><br><span class="line">    <span class="type">int</span> option, str_len;</span><br><span class="line">    <span class="type">socklen_t</span> optlen, client_addr_sz;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, client_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;socket() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    optlen = <span class="built_in">sizeof</span>(option);</span><br><span class="line">    option = TRUE;</span><br><span class="line">    <span class="built_in">setsockopt</span>(serv_sock, SOL_SOCKET, SO_REUSEADDR, (<span class="type">void</span>*)&amp;option, optlen);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client_addr_sz = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    client_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_addr_sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((str_len = <span class="built_in">read</span>(client_sock, message, <span class="built_in">sizeof</span>(message))) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(client_sock, message, str_len);</span><br><span class="line">        <span class="built_in">write</span>(<span class="number">1</span>, message, str_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(client_sock);</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​        在主机A的四次握手过程中，如果最后的数据丢失，则主机B会认为主机A未收到自己发送的FIN消息，因此重传。这时，收到FIN消息的主机A将重启Time-wait计时器。因此，如果网络状况不理想，Time-wait状态将持续。</p>
<p>​		解决方案就是在套接字的可选项中更改SO_REUSEADDR的状态。适当调整该参数，可将Time-wait状态下的套接字端口号重新分配给新的套接字。SO_REUSEADDR的默认值为0(假)，这就意味着无法分配Time-wait状态下的套接字端口号。因此需要将这个值改成1(真)。具体做法为上述代码中的 <font color=red>39-41行。</font></p>
</blockquote>
<h2 id="5-TCP-NODELAY"><a href="#5-TCP-NODELAY" class="headerlink" title="5. TCP_NODELAY"></a>5. TCP_NODELAY</h2><h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><p>​		TCP套接字默认使用Nagle算法，因此最大限度的进行缓冲，直到收到ACK。</p>
<p>如下图左侧：</p>
<p>​		为了发送字符串”Nagle”，将其传递到输出缓冲区。这时头字符’N’之前没有其他数据(没有需接收的ACK)，因此立即传输。之后开始等待字符’N’的ACK消息，等待过程中，剩下的”agle”填入缓冲。接下来，收到字符’N’的ACK消息后，将输出缓冲区的”agle”装入一个数据包发送。也就是说，<font color=orange>一共需要4个数据包以传输1个字符串</font></p>
<p>​		</p>
<p>如下图右侧：</p>
<p>​		对于未使用Nagle算法时发送字符串”Nagle”：假设字符’N’到’e’依次传到输入缓冲区。此时的发送过程与ACK接受与否无关，因此数据到达缓冲区后将立即被发送出去。从图中可以看到，发送字符串”Nagle”一共需要10个数据包。</p>
<p>​		<font color=green>因此，不使用Nagle算法将对网络流量产生负面影响。即使只传输1个字节的数据，其头信息都有可能是几十个字节。因此为了提高网络传输效率，必须使用Nagle算法。但Nagle算法并不是什么时候都适应。根据传输数据的特性，网络流量未受太大影响时，不使用Nagle算法要比使用它时传输速度快。</font></p>
<p>​		<font color=blue>一般情况下，不使用Nagle算法可以提高传输速度。但如果无条件放弃使用Nagle算法，就会增加过多的网络流量，反而会影响传输。</font></p>
<p><img src="/../picture/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%8F%AF%E9%80%89%E9%A1%B9/5c42e12abc5b8.png" alt="5c42e12abc5b8"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h3 id="禁用Nagle算法"><a href="#禁用Nagle算法" class="headerlink" title="禁用Nagle算法"></a>禁用Nagle算法</h3><p>​		只需要将套接字可选项TCP_NODELAY改为1(真)即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> opt_val = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sock, IPPROTO_TCP, ICP_NODELAY, (<span class="type">void</span>*)&amp;opt_val, <span class="built_in">sizeof</span>(opt_val));</span><br></pre></td></tr></table></figure>

<p>​		可以通过TCP_NODELAY的值查看Nagle算法的设置状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> opt_val;</span><br><span class="line"><span class="type">socklen_t</span> opt_len;</span><br><span class="line">opt_len = <span class="built_in">sizeof</span>(opt_val);</span><br><span class="line"><span class="built_in">getsockopt</span>(sock, IPPROTO_TCP, ICP_NODELAY, (<span class="type">void</span>*)&amp;opt_val, &amp;opt_val);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>域名及网络地址</title>
    <url>/2024/07/17/%E5%9F%9F%E5%90%8D%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h2 id="1-域名系统"><a href="#1-域名系统" class="headerlink" title="1.域名系统"></a>1.域名系统</h2><p>​    DNS是对IP地址和域名进行相互转换的系统，其核心是DNS服务器。</p>
<h2 id="2-IP地址和域名之间的转换"><a href="#2-IP地址和域名之间的转换" class="headerlink" title="2. IP地址和域名之间的转换"></a>2. IP地址和域名之间的转换</h2><p>​        IP地址比域名发生变更的频率要高，所以利用IP地址编写程序并非上策。还有什么解决办法呢？一旦注册域名可能永久不变，因此利用域名编程程序可能会好一些。这样，每次程序运行时根据域名获取IP地址，再接入服务器，这样程序就不会依赖于服务器IP地址了。所以说，<strong>程序中也需要IP地址和域名之间的转换函数。</strong></p>
<h2 id="3-利用域名获取-IP-地址"><a href="#3-利用域名获取-IP-地址" class="headerlink" title="3.利用域名获取 IP 地址"></a>3.利用域名获取 IP 地址</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过传递字符串格式的域名获取IP地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* <span class="built_in">gethostbyname</span>(<span class="type">const</span> <span class="type">char</span>* hostname);</span><br><span class="line">	-&gt; 成功时返回 hostent 结构体地址，失败时返回 <span class="literal">NULL</span> 指针。</span><br></pre></td></tr></table></figure>

<p>​        上面的函数只要传递域名字符串，就会返回域名对应的 IP 地址。返回时，地址信息装入 hostent 结构体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* h_name;	    <span class="comment">// 存储的是官方域名</span></span><br><span class="line">    <span class="type">char</span>** h_aliases;   <span class="comment">// 可以通过多个域名访问同一主页。同一 IP 可以绑定多个域名</span></span><br><span class="line">    <span class="type">int</span> h_addrtype;	    <span class="comment">// 通过此变量获取h_addr_list的IP地址的地址族信息(支持IPv4、IPv6)</span></span><br><span class="line">    <span class="type">int</span> h_length;       <span class="comment">// IP地址长度,IPv4长度为4字节，保存4；IPv6长度为16字节，保存16</span></span><br><span class="line">    <span class="type">char</span>** h_addr_list; <span class="comment">// 以整数形式保存域名对应的IP地址；用户较多的网站可能分配多个IP给					  </span></span><br><span class="line">    				  <span class="comment">// 同一域名，利用多个服务器进行负载均衡。同样可以使用此便行获取IP地址信息。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Example:</strong></em></p>
<blockquote>
<p>gethostbyname.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handing</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hostent</span>* host;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;addr&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    host = <span class="built_in">gethostbyname</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!host)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handing</span>(<span class="string">&quot;gethostname error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Offical name: %s\n&quot;</span>, host-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; host-&gt;h_aliases[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Aliases %d: %s\n&quot;</span>, i + <span class="number">1</span>, host-&gt;h_aliases[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address type: %s\n&quot;</span>, (host-&gt;h_addrtype == AF_INET) ? <span class="string">&quot;AF_INET&quot;</span> : <span class="string">&quot;AF_INET6&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; host-&gt;h_addr_list[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP addr %d: %s\n&quot;</span>, i + <span class="number">1</span>, <span class="built_in">inet_ntoa</span>(*(<span class="keyword">struct</span> in_addr*)host-&gt;h_addr_list[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result:</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/tcpip# g++ gethostbyname.cpp -o hostname</span><br><span class="line">root@jarryli:/tcpip# ./hostname www.naver.com</span><br><span class="line">Offical name: www.g.naver.com</span><br><span class="line">Aliases 1: www.naver.com</span><br><span class="line">IP addr 1: 202.131.29.70</span><br><span class="line">IP addr 2: 222.122.195.6</span><br></pre></td></tr></table></figure>



<h2 id="4-利用域名获取-IP-地址"><a href="#4-利用域名获取-IP-地址" class="headerlink" title="4.利用域名获取 IP 地址"></a>4.利用域名获取 IP 地址</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* <span class="built_in">gethostbyaddr</span>(<span class="type">const</span> <span class="type">char</span>* addr, <span class="type">socklen_t</span> len, <span class="type">int</span> family);</span><br><span class="line">	-&gt; 成功返回 hostent 结构体变量的地址，失败时返回 <span class="literal">NULL</span> 指针</span><br><span class="line">        • addr		含有IP地址信息的in_addr结构体。为了同时传递IPv4之外的地址，变量类型为<span class="type">char</span>*</span><br><span class="line">        • len		向第一个参数传递的地址信息的字节数，IPv4时为<span class="number">4</span>，IPv6时为<span class="number">16</span></span><br><span class="line">        • family	传递地址族信息，IPv4为AF_INET，IPv6时为AF_INET6</span><br></pre></td></tr></table></figure>

<p><em><strong>Example：</strong></em></p>
<blockquote>
<p>gethostbyaddr.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handing</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hostent</span>* host;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    host = <span class="built_in">gethostbyaddr</span>((<span class="type">char</span>*)&amp;addr.sin_addr, <span class="number">4</span>, AF_INET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!host)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handing</span>(<span class="string">&quot;gethostbyaddr error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Official name: %s\n&quot;</span>, host-&gt;h_name);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; host-&gt;h_aliases[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Aliases %d: %s\n&quot;</span>, i + <span class="number">1</span>, host-&gt;h_aliases[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address type: %s\n&quot;</span>, (host-&gt;h_addrtype == AF_INET) ? <span class="string">&quot;AF_INET&quot;</span> : <span class="string">&quot;AF_INET6&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; host-&gt;h_addr_list[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP addr %d: %s\n&quot;</span>, i + <span class="number">1</span>, <span class="built_in">inet_ntoa</span>(*(<span class="keyword">struct</span> in_addr*)host-&gt;h_addr_list[i]));</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result：</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/tcpip# g++ gethostbyaddr.cpp -o byaddr</span><br><span class="line">root@jarryli:/tcpip# ./byaddr 127.0.0.1</span><br><span class="line">Official name: localhost</span><br><span class="line">Address type: AF_INET</span><br><span class="line">IP addr 1: 127.0.0.1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>多进程服务器端</title>
    <url>/2024/07/18/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="1-并发服务器端的实现方法"><a href="#1-并发服务器端的实现方法" class="headerlink" title="1. 并发服务器端的实现方法"></a>1. 并发服务器端的实现方法</h2><blockquote>
<ul>
<li>多进程服务器：通过创建多个进程提供服务。</li>
<li>多路复用服务器：通过捆绑并统一管理 I&#x2F;O 对象提供服务。</li>
<li>多线程服务器：通过生成与客户端等量的线程提供服务。</li>
</ul>
</blockquote>
<h2 id="2-进程"><a href="#2-进程" class="headerlink" title="2. 进程"></a>2. 进程</h2><p>​		<strong>进程</strong>：占用内存空间的正在运行的程序。</p>
<p>​		<strong>进程ID</strong>：无论进程是如何创建的，所有进程都会从操作系统分配到ID。此ID称为“进程ID”，其值为大于2的整数。因为1要分配给操作系统启动后的(用于协助操作系统)首个进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps au #可以查看Linux正在运行的进程</span><br></pre></td></tr></table></figure>

<p><img src="/../picture/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/image-20240717155510106.png" alt="image-20240717155510106"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<h2 id="3-通过-fork-函数创建进程"><a href="#3-通过-fork-函数创建进程" class="headerlink" title="3. 通过 fork 函数创建进程"></a>3. 通过 fork 函数创建进程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	-&gt; 成功返回进程ID，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>​		fork 函数将创建调用的进程副本。也就是说，并非根据完全不同的程序创建进程，而是复制正在运行的、调用fork函数的进程。另外，两个进程都将执行fork函数调用后的语句(准确的说是在fork函数返回后)。<font color=red>但因为通过同一个进程、复制相同的内存空间，之后的程序流要根据fork函数的返回值加以区分</font>。即利用fork函数的如下特点区分程序执行流程。</p>
<pre><code>* 父进程(原进程)： fork函数返回子进程ID
* 子进程：fork函数返回0
</code></pre>
<p><em><strong>Example:</strong></em></p>
<blockquote>
<p>fork.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> gval = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> lval = <span class="number">20</span>;</span><br><span class="line">    gval++, lval += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    pid = fork();	<span class="comment">// 复制发生点</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gval += <span class="number">2</span>;</span><br><span class="line">        lval += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        gval -= <span class="number">2</span>;</span><br><span class="line">        lval -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child Proc: [%d,%d]\n&quot;</span>, gval, lval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent Proc: [%d,%d]\n&quot;</span>, gval, lval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result:</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# g++ fork.cpp -o fork</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# ./fork </span><br><span class="line">Parent Proc: [9,23]</span><br><span class="line">Child Proc: [13,27]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从运行结果可以看出，调用fork函数后，父子进程拥有完全独立的内存结构。</span></span><br></pre></td></tr></table></figure>



<h2 id="4-进程和僵尸进程"><a href="#4-进程和僵尸进程" class="headerlink" title="4. 进程和僵尸进程"></a>4. 进程和僵尸进程</h2><p><strong>僵尸进程</strong>：进程完成工作后没有被销毁，仍占用系统中的重要资源。</p>
<p>​	</p>
<p><strong>僵尸进程产生的原因</strong></p>
<ul>
<li>传递参数并调用 exit 函数</li>
<li>main 函数中执行 return 语句并返回值</li>
</ul>
<p>​	    向 exit 传递的参数值和 main 函数的 return 语句返回值都会传递给操作系统。而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程。处在这种状态下的进程就是僵尸进程。也就是说，将子进程变为僵尸进程的正是操作系统。</p>
<p><strong>僵尸进程如何销毁呢？</strong> <font color=red>应该向创建子进程的父进程传递子进程的 exit 参数值或 return 语句的返回值</font></p>
<p><strong>如何向父进程传递这些值呢？</strong>操作系统不会主动把这些值传递给父进程。只有父进程主动发起请求(函数调用)时，操作系统才会传递该值。换言之，如果父进程未主动要求获取子进程的结束状态值，操作系统将一直保存，并让子进程长时间处于僵尸进程状态。</p>
<p><em><strong>Example:</strong></em></p>
<blockquote>
<p>zombie.cpp</p>
</blockquote>
<p>​		</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is child process!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child process ID: &quot;</span> &lt;&lt; pid &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;End child process!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;End parent process!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result:</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# g++ zombie.cpp -o zombie</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# ./zombie</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在<span class="built_in">sleep</span>(30)过程中，PID为1938的进程变为了僵尸进程(Z+)</span></span><br></pre></td></tr></table></figure>

<p><img src="/../picture/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/image-20240717172209449.png" alt="image-20240717172209449"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><font color=Orange>PS:  后台处理：.&#x2F;zombie &amp; 如果以这种方式运行程序，即可在一个控制台下输入命令，无需打开额外的控制台。</font></p>
<h2 id="5-销毁僵尸进程"><a href="#5-销毁僵尸进程" class="headerlink" title="5. 销毁僵尸进程"></a>5. 销毁僵尸进程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span>* statloc)</span></span>;</span><br><span class="line">	-&gt; 成功返回终止的子进程ID，失败时返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>​		调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值(exit 函数的参数值、main 函数的 return 返回值)将保存到该函数的参数所指向内存空间。但函数参数指向的单元中还包含其他信息，因此需要通过下面的宏进行分离：</p>
<blockquote>
<ul>
<li>WIFEXITEDL		子进程正常终止时返回真(true)</li>
<li>WEXITSTATUS     返回子进程的返回值</li>
</ul>
</blockquote>
<p><em><strong>Example：</strong></em></p>
<blockquote>
<p>wait.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child PID: %d\n&quot;</span>, pid);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child PID: %d\n&quot;</span>, pid);</span><br><span class="line">            <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Child send one: %d\n&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">wait</span>(&amp;status); <span class="comment">// 以为之前创建了两个进程，所以要再次调用</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Child send two: %d\n&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result:</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# g++ wait.cpp -o wait</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# ./wait </span><br><span class="line">Child PID: 2022</span><br><span class="line">Child PID: 2023</span><br><span class="line">Child send one: 3</span><br><span class="line">Child send two: 7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ps au 查看后并无上述结果中的PID对应的进程，这是因为调用了<span class="built_in">wait</span>函数完全销毁了该进程，另外两个子进程终止时返回值传递给了父进程</span></span><br></pre></td></tr></table></figure>

<p><font color=orange>PS: 调用wait函数时，如果没有已终止的子进程，那么程序将阻塞(Blocking)直到有子进程终止，需要谨慎调用该函数。</font></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式2：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* statloc, <span class="type">int</span> options)</span></span>;</span><br><span class="line">	-&gt; 成功时返回终止的子进程<span class="built_in">ID</span>(或<span class="number">0</span>)，失败时返回<span class="number">-1</span></span><br><span class="line">        • pid 		等到终止的目标子进程ID，若传递<span class="number">-1</span>，则与wait函数相同，可以等待任意子进程终止</span><br><span class="line">        • statloc	保存子进程的返回值(与 wait 函数中的参数作用一致)</span><br><span class="line">        • options	传递头文件sys/wait.h中的常量WNOHANG，即使没有终止的子进程也不会进入阻塞状态，而是返回<span class="number">0</span>并退出函数</span><br></pre></td></tr></table></figure>

<p><em><strong>Example：</strong></em></p>
<blockquote>
<p>waitpid.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">15</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, WNOHANG))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;sleep 3 sec!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child send %d\n&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result：</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# g++ waitpid.cpp -o wait</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# ./wait </span><br><span class="line">sleep 3 sec!</span><br><span class="line">sleep 3 sec!</span><br><span class="line">sleep 3 sec!</span><br><span class="line">sleep 3 sec!</span><br><span class="line">sleep 3 sec!</span><br><span class="line">Child send 24</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">waitpid 不会阻塞</span></span><br></pre></td></tr></table></figure>



<h2 id="6-信号、signal-函数与-sigaction-函数"><a href="#6-信号、signal-函数与-sigaction-函数" class="headerlink" title="6. 信号、signal 函数与 sigaction 函数"></a>6. 信号、signal 函数与 sigaction 函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="built_in">void</span> (*<span class="built_in">signal</span>(<span class="type">int</span> signo, <span class="built_in">void</span> (*<span class="built_in">func</span>(<span class="type">int</span>))))(<span class="type">int</span>);</span><br><span class="line">	-&gt; 为了在产生信号时调用，返回之前注册的函数指针</span><br><span class="line">        • signo				特殊情况信息</span><br><span class="line">        • <span class="built_in">void</span> (*<span class="built_in">func</span>(<span class="type">int</span>))	 特殊情况下将要调用的函数的地址值(指针)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">signal</span>(SIGNA:, mychild);  <span class="comment">// 定义了子进程终止的情况，signal 函数的第一个参数，signal 函数的第二个参数为处理 SIGNAL 的函数</span></span><br><span class="line">	-&gt; signal 函数中注册的部分(SIGNAL 部分)特殊情况和对应的常数:</span><br><span class="line">            • SIGALRM		已经通过调用 alarm 函数注册的时间</span><br><span class="line">            • SIGINT		输入 CTRL + C</span><br><span class="line">            • SIGCHLD		子进程终止</span><br></pre></td></tr></table></figure>

<p>​		以上就是信号注册过程，注册好信号后，发生注册信号时(注册的情况发生时)，将调用该信号对应的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span>;</span><br><span class="line">	-&gt; 返回<span class="number">0</span>或以秒为单位的距SIGALRM信号发生的所剩时间</span><br></pre></td></tr></table></figure>

<p>​		<font color=green>如果调用该函数的同时向他传递一个正整形参数，相应时间后(以秒为单位)将产生SIGALRM信号。若向该函数传递0，则之前对SIGALRM信号的预约将取消。如果通过该函数预约信号后未指定该信号对应的处理函数，则(通过调用 signal 函数)终止进程，不做任何处理。</font></p>
<p><em><strong>Example:</strong></em></p>
<blockquote>
<p>signal.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timeout</span><span class="params">(<span class="type">int</span> sig)</span> <span class="comment">// 信号处理器</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGALRM)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Time out!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">2</span>); <span class="comment">// 为了每隔2s重复产生SIGALRM信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">keycontrol</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGINT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;CTRL + C pressed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">signal</span>(SIGALRM, timeout);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, keycontrol);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">2</span>); <span class="comment">// 预约2秒发生SIGALRM信号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result:</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">没有按 CTRL + C</span></span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# g++ signal.cpp -o signal</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# ./signal </span><br><span class="line">wait...</span><br><span class="line">Time out!</span><br><span class="line">wait...</span><br><span class="line">Time out!</span><br><span class="line">wait...</span><br><span class="line">Time out!</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有按 CTRL + C</span></span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# g++ signal.cpp -o signal</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# ./signal </span><br><span class="line">wait...</span><br><span class="line">^CCTRL + C pressed!</span><br><span class="line">wait...</span><br><span class="line">Time out!</span><br><span class="line">wait...</span><br><span class="line">^CCTRL + C pressed!</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过上面的Example可以看出：<font color=Greenyellow>发生信号时将唤醒由于调用sleep函数而进入阻塞状态的进程。</font></p>
</blockquote>
<blockquote>
<p><font color=Greenyellow>		调用函数的主体的确是操作系统，但进程处于睡眠状态时无法调用函数。因此，产生信号时，为了调用信号处理器，将唤醒由于调用sleep函数而进入阻塞状态的进程。而且，进程一旦被唤醒，就不会再进入休眠状态。即使还未到sleep函数中规定的时间也是如此。所以上面的代码不到10s就会结束，连续输入 CTRL + C 有可能1s都不到。</font></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> signo, <span class="type">const</span> <span class="keyword">struct</span> sigaction* act, <span class="keyword">struct</span> sigaction* oldact)</span></span>;</span><br><span class="line">	-&gt; 成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br><span class="line">        • signo		特殊情况信息</span><br><span class="line">        • act		对应第一个参数的信号处理函数(信号处理器)信息</span><br><span class="line">        • oldact	通过此参数获取之前注册的信号处理函数指针，若不需要则传递<span class="number">0</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> (*sa_handler)(<span class="type">int</span>);	<span class="comment">// 保存信号处理函数的指针值(地址值)</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;		    </span><br><span class="line">    <span class="type">int</span> sa_flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sa_mast 和 sa_flags 的所有位均初始化为0即可，这两个成员用于指定信号相关的选项和特性。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color=Aqua>		signal函数可以完全代替sigaction函数，而且signal函数更稳定。signal函数在UNIX系列的不同操作系统中可能存在不同，但是sigaction函数完全相同，为了兼容性，更多的使用sigaction函数。</font></p>
</blockquote>
<p><em><strong>Example:</strong></em></p>
<blockquote>
<p>sigaction.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timeout</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGALRM)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Time out!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    act.sa_handler = timeout; <span class="comment">// 保存函数指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask); <span class="comment">// 将sa_mask 函数的所有位初始化为0</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGALRM, &amp;act, <span class="number">0</span>); <span class="comment">// 注册 SIGALRM 信号的处理器</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">2</span>); <span class="comment">// 2s后发生 SIGALRM 信号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result:</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# g++ sigaction.cpp -o sigaction</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# ./sigaction</span><br><span class="line">wait...</span><br><span class="line">Time out!</span><br><span class="line">wait...</span><br><span class="line">Time out!</span><br><span class="line">wait...</span><br><span class="line">Time out!</span><br></pre></td></tr></table></figure>



<h2 id="7-利用信号处理技术消灭僵尸进程"><a href="#7-利用信号处理技术消灭僵尸进程" class="headerlink" title="7. 利用信号处理技术消灭僵尸进程"></a>7. 利用信号处理技术消灭僵尸进程</h2><p><font color=Greenyellow>子进程结束的时候会产生 SIGCHLD 信号</font></p>
<p><em><strong>Example：</strong></em></p>
<blockquote>
<p>remove_zombie.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_childproc</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> id = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, WNOHANG);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Removed proc id: %d\n&quot;</span>, id); <span class="comment">// 子进程的pid</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child send: %d\n&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status)); <span class="comment">// 子继承的返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    act.sa_handler = read_childproc;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;This is child process1!&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child proc id: %d\n&quot;</span>, pid);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;This is child process2!&quot;</span>);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">24</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child proc id: %d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result：</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可能先释放第2个，也可能先释放第1个</span></span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# g++ remove_zombie.cpp -o remove_zombie</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# ./remove_zombie </span><br><span class="line">Child proc id: 2616</span><br><span class="line">This is child process1!</span><br><span class="line">Child proc id: 2617</span><br><span class="line">wait...</span><br><span class="line">This is child process2!</span><br><span class="line">wait...</span><br><span class="line">Removed proc id: 2616</span><br><span class="line">Child send: 12</span><br><span class="line">wait...</span><br><span class="line">Removed proc id: 2617</span><br><span class="line">Child send: 24</span><br><span class="line">wait...</span><br><span class="line">wait...</span><br></pre></td></tr></table></figure>



<h2 id="8-基于多任务的并发服务器"><a href="#8-基于多任务的并发服务器" class="headerlink" title="8. 基于多任务的并发服务器"></a>8. 基于多任务的并发服务器</h2><p><strong>基于进程的并发服务器模型</strong></p>
<p><img src="/../picture/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/5c453664cde26.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>​		每当有客户端请求服务时（连接请求时），回声服务器端都创建子进程以提供服务。请求服务的客户端若有10个，则将创建10个子进程提供服务。为了完成这些任务，需要经历以下过程：</p>
<pre><code>- &lt;font color=Aqua&gt;第一阶段：回声服务器端（父进程）通过调用 accept 函数受理连接的请求；&lt;/font&gt;
- &lt;font color=Aqua&gt;第二阶段：此时获取的套接字文件描述符创建并传递给子进程；&lt;/font&gt;
- &lt;font color=Aqua&gt;第三阶段：子进程利用传递来的文件描述符体提供服务。&lt;/font&gt;
</code></pre>
<p><em><strong>容易引起误解的是：子进程传递套接字文件描述符的方法：子进程会复制父进程的所有资源，不需要通过另外经过传递文件描述符的过程。</strong></em></p>
<p><em><strong>Example：</strong></em></p>
<blockquote>
<p>echo_mpserver.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_childproc</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;remove proc: %d\n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clnt_addr;</span><br><span class="line">    <span class="type">int</span> str_len, state;</span><br><span class="line">    <span class="type">socklen_t</span> addr_sz;</span><br><span class="line">    <span class="type">char</span> buff[BUFF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    act.sa_handler = read_childproc;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        addr_sz = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line">        clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_addr, &amp;addr_sz);</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;client socket create error! reason: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;new client connected...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pid = fork(); <span class="comment">// 此时父子进程分别带有一个套接字</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(serv_sock); <span class="comment">// 关闭服务器套接字，因为子进程共享了父进程的资源</span></span><br><span class="line">            <span class="keyword">while</span> ((str_len = <span class="built_in">read</span>(clnt_sock, buff, BUFF_SIZE)) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">write</span>(clnt_sock, buff, str_len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">close</span>(clnt_sock);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;client finished and disconnect successfully!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>echo_mpclient.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span>* buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> str_len = <span class="built_in">read</span>(sock, buf, BUFF_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (str_len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buf[str_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span>* buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fgets</span>(buf, BUFF_SIZE, stdin);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 向服务器传递EOF，因为fork函数复制了文件描述组，所以调用1次close不够</span></span><br><span class="line">            <span class="built_in">shutdown</span>(sock, SHUT_WR); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(sock, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> buff[BUFF_SIZE];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write_routine</span>(sock, buff);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read_routine</span>(sock, buff);</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><strong>Result：</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">server</span></span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# ./server 9190</span><br><span class="line">new client connected...</span><br><span class="line">client finished and disconnect successfully!</span><br><span class="line"></span><br><span class="line">remove proc: 2093</span><br><span class="line">client socket create error! reason: Interrupted system call</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">client</span></span><br><span class="line"></span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# ./client 127.0.0.1 9190</span><br><span class="line">demo</span><br><span class="line">Message from server: demo</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">42行调用shutdown函数向服务器端传递EOF。当然执行43行<span class="built_in">return</span>语句之后会调用84行的close函数传递EOF。但是现在已经通过了fork函数复制了文件描述符，此时无法通过一次close函数调用传递EOF，因此需要调用shutdown函数调用另外传递。</span>    </span><br></pre></td></tr></table></figure>



<h3 id="通过-fork-函数复制文件描述符"><a href="#通过-fork-函数复制文件描述符" class="headerlink" title="通过 fork 函数复制文件描述符"></a>通过 fork 函数复制文件描述符</h3><p>​		上面的 echo_mpserver.cpp 中，父进程将2个套接字（一个是服务器端套接字，另一个是客户端连接的套接字）文件描述符复制给了子进程。</p>
<p>​		但是套接字并没有复制给子进程，从严格意义上来讲，套接字属于操作系统—-试试进程拥有代表相应套接字的文件描述符。仅因为如下原因，复制套接字也并不合理。<font color=oragne>复制套接字后，同一端口将对应多个套接字。</font></p>
<p>​		echo_mpserver.cpp 中 fork 函数调用过程如下：（调用 fork 函数后，2个文件描述符指向同一个套接字）</p>
<p><img src="/../picture/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/image-20240718083506049.png" alt="image-20240718083506049"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><font color=red>		如上图，1个套接字中存在2个文件描述符时，只有2个文件描述符都终止（销毁）后，才能销毁套接字。如果维持图中的连接状态，即使子进程销毁了与客户端连接的套接字文件描述符，也无法完全销毁套接字（服务器端套接字也是如此）。因此调用 fork 函数后，要将无关的套接字文件描述符都关掉。</font>如下图：</p>
<p><img src="/../picture/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/image-20240718083813302.png" alt="image-20240718083813302"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>echo_mpserver.cpp 中 88行、101行分别调用了 close 函数。</p>
<h2 id="9-分割-TCP-的-I-O-程序"><a href="#9-分割-TCP-的-I-O-程序" class="headerlink" title="9. 分割 TCP 的 I&#x2F;O 程序"></a>9. 分割 TCP 的 I&#x2F;O 程序</h2><h3 id="分割-TCP-的-I-O-程序-的优点"><a href="#分割-TCP-的-I-O-程序-的优点" class="headerlink" title="分割 TCP 的 I&#x2F;O 程序 的优点"></a>分割 TCP 的 I&#x2F;O 程序 的优点</h3><p><strong>之前的回声客户端的数据回声方式如下：</strong> 向服务器端传输数据，等待服务器端回复。无条件的等待，直到接收完服务器端的回声数据后，才能传输下一批数据。</p>
<p>​		因为程序代码中重复调用了 read 和 write 函数，但是<strong>现在考虑分割数据收发过程：</strong></p>
<p>客户端的父进程负责接收数据，额外创建的子进程负责发送数据。分割后，不同进程分别负责输入和输出，这样，无论客户端是否从服务器端接收完数据都可以进行传输。</p>
<p><img src="/../picture/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/image-20240718085056086.png" alt="image-20240718085056086"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p><strong>另外一个优点</strong>：可以提交频繁交换数据的程序性能。</p>
<p><img src="/../picture/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/image-20240718085157220.png" alt="image-20240718085157220"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p>
<p>​		左侧的是之前的回声客户端，右侧的是分割 I&#x2F;O 后的客户端接收数据传输方式。分割 I&#x2F;O 后的客户端发送数据时不必考虑接收数据的情况，因此可以连续发送数据，由此提高同一时间内传输的数据量。这种差异在网络较慢时尤为明显。</p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>进程间通信</title>
    <url>/2024/07/23/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h3 id="1-进程间通信的基本概念"><a href="#1-进程间通信的基本概念" class="headerlink" title="1. 进程间通信的基本概念"></a>1. 进程间通信的基本概念</h3><p>​		进程间通信(Inter Process Communication)意味着两个不同的进程间可以交换数据，为了这一点，操作系统中应该提供两个进程可以同时访问的内存空间。</p>
<h3 id="2-通过管道实现进程间通信"><a href="#2-通过管道实现进程间通信" class="headerlink" title="2. 通过管道实现进程间通信"></a>2. 通过管道实现进程间通信</h3><img src="../picture/进程间通信/image-20240722231219710.png" alt="image-20240722231219710"    data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'/>

<p>​		</p>
<p>​		为了完成进程间的通信，需要创建管道。管道并非属于进程间的资源，而是和套接字一样，属于操作系统（也就不是fork函数复制的对象）。所以，两个进程通过操作系统提供的内存空间进行通信。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> filedes[<span class="number">2</span>])</span></span>;</span><br><span class="line">	-&gt; 成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br><span class="line">        • filedes[<span class="number">0</span>]	通过管道 接收 数据时使用的文件描述符，即管道出口</span><br><span class="line">        • filedes[<span class="number">1</span>]	通过管道 传输 数据时使用的文件描述符，即管道入口</span><br></pre></td></tr></table></figure>

<p><font color=Aqua>		以长度为2的int数组地址值作为参数调用上述函数时，数组中存有两个文件描述符，它们将被用作管道的出口和入口。父进程调用该函数时将创建管道，同时获取对应于出入口的文件描述符，此时父进程可以读写同一管道。但父进程的目的是与子进程进行数据交换，因此需要将入口或出口中的1个文件描述符传递给子进程。如何完成传递呢?答案就是调用fork函数。</font>&gt;</p>
<p><em><strong>Example:</strong></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> str[] = <span class="string">&quot;Who are you?&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 pipe 函数创建管道，fds 数组中保存用于I/O的文件描述符</span></span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line">    pid = fork(); <span class="comment">// 子进程将同时拥有创建管道获取的2个文件描述符，复制的并非管道，而是文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], str, <span class="built_in">sizeof</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(fds[<span class="number">0</span>], buf, BUFF_SIZE);</span><br><span class="line">        std::cout &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result:</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter11# g++ pipe1.cpp -o pipe1</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter11# ./pipe1 </span><br><span class="line">Who are you?</span><br></pre></td></tr></table></figure>

<img src="../picture/进程间通信/image-20240722232150577.png" alt="image-20240722232150577"    data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'/>



<h3 id="3-通过管道进行进程间双向通信"><a href="#3-通过管道进行进程间双向通信" class="headerlink" title="3. 通过管道进行进程间双向通信"></a>3. 通过管道进行进程间双向通信</h3><img src="../picture/进程间通信/image-20240722232514373.png" alt="image-20240722232514373"    data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'/>



<p>​		<font color=Greenyellow>通过一个管道也可以进行双向通信，但是采用这种模型需要格格外注意。</font></p>
<p><em><strong>Example:</strong></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> str1[] = <span class="string">&quot;Who are you?&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> str2[] = <span class="string">&quot;Thank you for your message!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFF_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], str1, <span class="built_in">sizeof</span>(str1));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">read</span>(fds[<span class="number">0</span>], buf, BUFF_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child proc output: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(fds[<span class="number">0</span>], buf, BUFF_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent proc output: %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">write</span>(fds[<span class="number">1</span>], str2, <span class="built_in">sizeof</span>(str2));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result:</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter11# g++ pipe2.cpp -o pipe2</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter11# ./pipe2 </span><br><span class="line">Parent proc output: Who are you?</span><br><span class="line">Child proc output: Thank you for your message!</span><br></pre></td></tr></table></figure>

<p><font color=red>WARNING: 当注释掉第20行sleep(2)后程序会卡死。</font></p>
<p><font color=SkyBlue>		分析: 产生的原因是”向管道传递数据时，先读的进程会把数据读走“。即数据进入管道后成为无助无主数据，也就是通过 read 函数先读取数据的进程先得到数据，即使该进程将数据传到了管道。</font></p>
<img src="../picture/进程间通信/image-20240722234804043.png" alt="image-20240722234804043"    data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'/>

<p>因此可以通过创建 <strong>两个管道</strong> 进行进程间的通信。</p>
<p><em><strong>Example:</strong></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fds1[<span class="number">2</span>], fds2[<span class="number">2</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> str1[] = <span class="string">&quot;Who are you?&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> str2[] = <span class="string">&quot;Thank you for your message!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFF_SIZE];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pipe</span>(fds1), <span class="built_in">pipe</span>(fds2);</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(fds1[<span class="number">1</span>], str1, <span class="built_in">sizeof</span>(str1));</span><br><span class="line">        <span class="built_in">read</span>(fds2[<span class="number">0</span>], buf, BUFF_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child proc output: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(fds1[<span class="number">0</span>], buf, BUFF_SIZE);</span><br><span class="line">        <span class="built_in">write</span>(fds2[<span class="number">1</span>], str2, <span class="built_in">sizeof</span>(str2));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent proc output: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result:</strong></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter11# g++ pipe3.cpp -o pipe3</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter11# ./pipe3 </span><br><span class="line">Parent proc output: Who are you?</span><br><span class="line">Child proc output: Thank you for your message!</span><br></pre></td></tr></table></figure>



<h2 id="4-保存消息的回声服务器端"><a href="#4-保存消息的回声服务器端" class="headerlink" title="4. 保存消息的回声服务器端"></a>4. 保存消息的回声服务器端</h2><p><em><strong>Example:</strong></em></p>
<blockquote>
<p>echo_storeserv.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SIZE 300</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_childproc</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;status, WNOHANG);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;removed proc id: %d\n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr, clnt_addr;</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    <span class="type">socklen_t</span> addr_sz;</span><br><span class="line">    <span class="type">int</span> str_len, state;</span><br><span class="line">    <span class="type">char</span> buf[BUFF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    act.sa_handler = read_childproc;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注册信号器，把成功的返回值给 state</span></span><br><span class="line">    state = <span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="number">0</span>); </span><br><span class="line">   </span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">error_handling</span>(<span class="string">&quot;bind() error!&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;listen() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pipe</span>(fds);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;echomsg.txt&quot;</span>, <span class="string">&quot;wt&quot;</span>);</span><br><span class="line">        <span class="type">char</span> msgbuf[BUFF_SIZE];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            len = <span class="built_in">read</span>(fds[<span class="number">0</span>], msgbuf, BUFF_SIZE);</span><br><span class="line">            <span class="built_in">fwrite</span>((<span class="type">void</span>*)msgbuf, <span class="number">1</span>, len, fp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        addr_sz = <span class="built_in">sizeof</span>(clnt_addr);</span><br><span class="line">        clnt_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;clnt_addr, &amp;addr_sz);</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;new clinet connected...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pid = fork(); <span class="comment">// 此时，父子进程分别带有一个套接字</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// 提进程运行区域，此部分向客户端提供回声服务器</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(serv_sock);</span><br><span class="line">            <span class="keyword">while</span> ((str_len = <span class="built_in">read</span>(clnt_sock, buf, BUFF_SIZE)) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">write</span>(clnt_sock, buf, str_len);</span><br><span class="line">                <span class="built_in">write</span>(fds[<span class="number">1</span>], buf, str_len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;client disconnected...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 通过 accept 函数创建的套接字文件描述符已经复制给子进程，因为服务器端要销毁自己拥有的</span></span><br><span class="line">            <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>echo_mpclient.cpp</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handling</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, stderr);</span><br><span class="line">    <span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span>* buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> str_len = <span class="built_in">read</span>(sock, buf, BUFF_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (str_len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buf[str_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_routine</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span>* buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fgets</span>(buf, BUFF_SIZE, stdin);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 向服务器传递EOF，因为fork函数复制了文件描述组，所以调用1次close不够</span></span><br><span class="line">            <span class="built_in">shutdown</span>(sock, SHUT_WR); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(sock, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> buff[BUFF_SIZE];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handling</span>(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write_routine</span>(sock, buff);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read_routine</span>(sock, buff);</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Result:</strong></em></p>
<blockquote>
<p>server</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter11# g++ echo_storeserv.cpp -o server</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter11# ./server 9190</span><br><span class="line">new clinet connected...</span><br><span class="line">client disconnected...</span><br><span class="line">removed proc id: 2396</span><br><span class="line">^C</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter11# ^C</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter11# g++ echo_storeserv.cpp -o server</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter11# ./server 9190</span><br><span class="line">new clinet connected...</span><br><span class="line">removed proc id: 2403</span><br><span class="line">client disconnected...</span><br><span class="line">removed proc id: 2410</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<blockquote>
<p>client -&gt; 客户端需要连续发10次数据</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# g++ echo_mpclient.cpp -o client</span><br><span class="line">root@jarryli:/home/jarryli/code/tcp_ip/chapter10# ./client 127.0.0.1 9190</span><br><span class="line">demo1</span><br><span class="line">Message from server: demo1</span><br><span class="line">demo2</span><br><span class="line">Message from server: demo2</span><br><span class="line">demo3</span><br><span class="line">Message from server: demo3</span><br><span class="line">demo4</span><br><span class="line">Message from server: demo4</span><br><span class="line">demo5</span><br><span class="line">Message from server: demo5</span><br><span class="line">demo6</span><br><span class="line">Message from server: demo6</span><br><span class="line">demo7</span><br><span class="line">Message from server: demo7</span><br><span class="line">demo8</span><br><span class="line">Message from server: demo8</span><br><span class="line">demo9</span><br><span class="line">Message from server: demo9</span><br><span class="line">demo10</span><br><span class="line">Message from server: demo10</span><br><span class="line">q</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
  </entry>
</search>
